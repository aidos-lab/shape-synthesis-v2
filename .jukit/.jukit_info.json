{"cmd": "\nr\"\"\"°°°\nBase example\n°°°\"\"\"\n\nimport numba\n\nimport numpy as np\nimport pyvista as pv\nimport torch\nfrom dect.directions import generate_uniform_directions\nfrom custom_ect import compute_ect\n\n\n# Settings\nRESOLUTION = 256\nRADIUS = 1.0\nSCALE = 256\n\n\ndef calc_idx(theta, xg, yg, zg):\n    R = RESOLUTION - 1\n    heights = theta[0] * xg + theta[1] * yg + theta[2] * zg\n    # idx = ((heights + 1) * RESOLUTION / 2).astype(np.int32) + 1\n    # idx.ravel()[idx.ravel() > R] = R\n    # return idx\n\n\ndef filtered_back_projection(\n    v,\n    ect,\n    resolution,\n    xg,\n    yg,\n    zg,\n    recon,\n):\n    for theta, slice in zip(v.T, ect.T):\n        idx = calc_idx(theta, xg, yg, zg)\n        # reps = slice.ravel()[idx.ravel()]\n        # recon += np.zeros_like(recon)\n    return recon\n\n\nxg, yg, zg = np.meshgrid(\n    np.linspace(-1, 1, RESOLUTION, endpoint=False),\n    np.linspace(-1, 1, RESOLUTION, endpoint=False),\n    np.linspace(-1, 1, RESOLUTION, endpoint=False),\n    indexing=\"ij\",\n    sparse=False,\n)\n\nrecon = np.zeros(shape=(RESOLUTION, RESOLUTION, RESOLUTION))\n\nv = generate_uniform_directions(RESOLUTION, d=3, seed=2025, device=\"cpu\")\nx = torch.load(\"x.pt\")\n\nect = compute_ect(x, v, radius=RADIUS, resolution=RESOLUTION, scale=SCALE)\n\ndensity = filtered_back_projection(\n    v.numpy().astype(np.float32),\n    ect.numpy().astype(np.float32),\n    resolution=RESOLUTION,\n    xg=xg,\n    yg=yg,\n    zg=zg,\n    recon=recon,\n)\n\n", "cmd_opts": " --cell_id=6bapWgakqP", "import_complete": 1, "terminal": "nvimterm"}